use std::sync::atomic::AtomicUsize;

use crate::{
    compiler::Compiler,
    prelude::{code::Code, syntax_rules::SyntaxRules, *}, utilities::arraylist::ArrayList,
};

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug)]
pub enum Arity {
    Exact(usize),
    AtLeast(usize),
}

impl Object for Arity {}
impl Allocation for Arity {
    const NO_HEAP_PTRS: bool = true;
}

static COUNT: AtomicUsize = AtomicUsize::new(0);

pub struct Procedure {
    pub(crate) id: usize,
    pub(crate) kind: ProcedureKind,
    pub(crate) module: Handle<Library>,
}

impl Procedure {
    pub fn name(&self) -> String {
        match &self.kind {
            ProcedureKind::Primitive(name, _, _) => name.to_string(),
            ProcedureKind::Closure(ClosureType::Named(name), _, _, _) => name.to_string(),
            _ => format!("<closure {}>", self.id),
        }
    }

    pub fn embedded_name(&self) -> String {
        match &self.kind {
            ProcedureKind::Primitive(name, _, _) => name.to_string(),
            ProcedureKind::Closure(ClosureType::Named(name), _, _, _) => name.to_string(),
            _ => format!("{}", self.id),
        }
    }

    pub fn arity(&self) -> &[Arity] {
        match self.kind {
            ProcedureKind::Primitive(_, ref imp, _) => match imp {
                Implementation::Native0(_) => &[Arity::Exact(0)],
                Implementation::Native1(_) => &[Arity::Exact(1)],
                Implementation::Native2(_) => &[Arity::Exact(2)],
                Implementation::Native3(_) => &[Arity::Exact(3)],
                Implementation::Native4(_) => &[Arity::Exact(4)],
                Implementation::Native0O(_) => &[Arity::Exact(0), Arity::Exact(1)],
                Implementation::Native1O(_) => &[Arity::Exact(1), Arity::Exact(2)],
                Implementation::Native2O(_) => &[Arity::Exact(2), Arity::Exact(3)],
                Implementation::Native3O(_) => &[Arity::Exact(3), Arity::Exact(4)],
                Implementation::Native0OO(_) => {
                    &[Arity::Exact(0), Arity::Exact(1), Arity::Exact(2)]
                }
                Implementation::Native1OO(_) => {
                    &[Arity::Exact(1), Arity::Exact(2), Arity::Exact(3)]
                }
                Implementation::Native2OO(_) => {
                    &[Arity::Exact(2), Arity::Exact(3), Arity::Exact(4)]
                }
                Implementation::Native3OO(_) => {
                    &[Arity::Exact(3), Arity::Exact(4), Arity::Exact(5)]
                }
                Implementation::Native0R(_) => &[Arity::AtLeast(0)],
                Implementation::Native1R(_) => &[Arity::AtLeast(1)],
                Implementation::Native2R(_) => &[Arity::AtLeast(2)],
                Implementation::Native3R(_) => &[Arity::AtLeast(3)],
                Implementation::Apply(_) | Implementation::Eval(_) => &[Arity::AtLeast(0)]
            },

            ProcedureKind::Closure(ClosureType::Continuation, _, _, _) => &[Arity::Exact(1)],
            ProcedureKind::Closure(_, _, _, ref code) => &code.arity(),
            ProcedureKind::Parameter(_) => &[Arity::Exact(0), Arity::Exact(1)],
            ProcedureKind::Transformer(_) => &[Arity::Exact(1)],
            ProcedureKind::RawContinuation(_) => &[Arity::Exact(1)],
        }
    }

    pub(crate) fn new_id() -> usize {
        COUNT.fetch_add(1, std::sync::atomic::Ordering::Relaxed)
    }
}

impl Object for Procedure {
    fn trace(&self, visitor: &mut dyn Visitor) {
        self.kind.trace(visitor);
        self.module.trace(visitor);
    }
}

impl Allocation for Procedure {}

pub enum ProcedureKind {
    Primitive(Handle<Str>, Implementation, Option<FormCompiler>),
    Parameter(Handle<Pair>),
    Closure(ClosureType, Value, Handle<Array<Handle<Upvalue>>>, Handle<Code>),
    RawContinuation(SavedState),
    Transformer(Handle<SyntaxRules>),
}

impl Object for ProcedureKind {
    fn trace(&self, visitor: &mut dyn Visitor) {
        match self {
            ProcedureKind::Primitive(name, _, _) => name.trace(visitor),
            ProcedureKind::Parameter(ls) => ls.trace(visitor),
            ProcedureKind::Closure(ty, proc, free_vars, code) => {
                if let ClosureType::Named(name) = ty {
                    name.trace(visitor);
                    proc.trace(visitor);
                    free_vars.trace(visitor);
                    code.trace(visitor);
                }
            }
            ProcedureKind::RawContinuation(state) => state.trace(visitor),
            ProcedureKind::Transformer(rules) => rules.trace(visitor),
        }
    }
}

/// There are three types of closures:
///    1. Anonymous closures: closures that are not named
///    2. Named closures: Closures that are given a name
///    3. Continuations: These are unnamed closures generated by `call-with-current-continuation`
#[derive(Clone, Copy, PartialEq, Eq)]
pub enum ClosureType {
    Anonymous,
    Named(Handle<Str>),
    Continuation,
}

pub enum Implementation {
    Apply(fn(&mut Context, &Arguments) -> (Handle<Procedure>, ArrayList<Value>)),
    Eval(fn(&mut Context, &Arguments) -> Handle<Code>),
    Native0(fn(&mut Context) -> Value),
    Native1(fn(&mut Context, Value) -> Value),
    Native2(fn(&mut Context, Value, Value) -> Value),
    Native3(fn(&mut Context, Value, Value, Value) -> Value),
    Native4(fn(&mut Context, Value, Value, Value, Value) -> Value),
    Native0O(fn(&mut Context, Option<Value>) -> Value),
    Native1O(fn(&mut Context, Value, Option<Value>) -> Value),
    Native2O(fn(&mut Context, Value, Value, Option<Value>) -> Value),
    Native3O(fn(&mut Context, Value, Value, Value, Option<Value>) -> Value),
    Native0OO(fn(&mut Context, Option<Value>, Option<Value>) -> Value),
    Native1OO(fn(&mut Context, Value, Option<Value>, Option<Value>) -> Value),
    Native2OO(fn(&mut Context, Value, Value, Option<Value>, Option<Value>) -> Value),
    Native3OO(fn(&mut Context, Value, Value, Value, Option<Value>, Option<Value>) -> Value),
    Native0R(fn(&mut Context, &Arguments) -> Value),
    Native1R(fn(&mut Context, Value, &Arguments) -> Value),
    Native2R(fn(&mut Context, Value, Value, &Arguments) -> Value),
    Native3R(fn(&mut Context, Value, Value, Value, &Arguments) -> Value),
}

impl Into<Implementation> for fn(&mut Context, &Arguments) -> (Handle<Procedure>, ArrayList<Value>) {
    fn into(self) -> Implementation {
        Implementation::Apply(self)
    }
}

impl Into<Implementation> for fn(&mut Context, &Arguments) -> Handle<Code> {
    fn into(self) -> Implementation {
        Implementation::Eval(self)
    }
}

impl Into<Implementation> for fn(&mut Context) -> Value {
    fn into(self) -> Implementation {
        Implementation::Native0(self)
    }
}

impl Into<Implementation> for fn(&mut Context, Value) -> Value {
    fn into(self) -> Implementation {
        Implementation::Native1(self)
    }
}

impl Into<Implementation> for fn(&mut Context, Value, Value) -> Value {
    fn into(self) -> Implementation {
        Implementation::Native2(self)
    }
}

impl Into<Implementation> for fn(&mut Context, Value, Value, Value) -> Value {
    fn into(self) -> Implementation {
        Implementation::Native3(self)
    }
}

impl Into<Implementation> for fn(&mut Context, Value, Value, Value, Value) -> Value {
    fn into(self) -> Implementation {
        Implementation::Native4(self)
    }
}

impl Into<Implementation> for fn(&mut Context, Option<Value>) -> Value {
    fn into(self) -> Implementation {
        Implementation::Native0O(self)
    }
}

impl Into<Implementation> for fn(&mut Context, Value, Option<Value>) -> Value {
    fn into(self) -> Implementation {
        Implementation::Native1O(self)
    }
}

impl Into<Implementation> for fn(&mut Context, Value, Value, Option<Value>) -> Value {
    fn into(self) -> Implementation {
        Implementation::Native2O(self)
    }
}

impl Into<Implementation> for fn(&mut Context, Value, Value, Value, Option<Value>) -> Value {
    fn into(self) -> Implementation {
        Implementation::Native3O(self)
    }
}

impl Into<Implementation> for fn(&mut Context, Option<Value>, Option<Value>) -> Value {
    fn into(self) -> Implementation {
        Implementation::Native0OO(self)
    }
}

impl Into<Implementation> for fn(&mut Context, Value, Option<Value>, Option<Value>) -> Value {
    fn into(self) -> Implementation {
        Implementation::Native1OO(self)
    }
}

impl Into<Implementation>
    for fn(&mut Context, Value, Value, Option<Value>, Option<Value>) -> Value
{
    fn into(self) -> Implementation {
        Implementation::Native2OO(self)
    }
}

impl Into<Implementation>
    for fn(&mut Context, Value, Value, Value, Option<Value>, Option<Value>) -> Value
{
    fn into(self) -> Implementation {
        Implementation::Native3OO(self)
    }
}

impl Into<Implementation> for fn(&mut Context, &Arguments) -> Value {
    fn into(self) -> Implementation {
        Implementation::Native0R(self)
    }
}

impl Into<Implementation> for fn(&mut Context, Value, &Arguments) -> Value {
    fn into(self) -> Implementation {
        Implementation::Native1R(self)
    }
}

impl Into<Implementation> for fn(&mut Context, Value, Value, &Arguments) -> Value {
    fn into(self) -> Implementation {
        Implementation::Native2R(self)
    }
}

impl Into<Implementation> for fn(&mut Context, Value, Value, Value, &Arguments) -> Value {
    fn into(self) -> Implementation {
        Implementation::Native3R(self)
    }
}

pub type Arguments = [Value];

pub trait ArgumentsExt {
    fn values(&self, ctx: &mut Context) -> Value;
}

impl ArgumentsExt for Arguments {
    fn values(&self, ctx: &mut Context) -> Value {
        match self.len() {
            0 => Value::void(),
            1 => self[0],
            _ => {
                let mut res = Value::new(Null);
                let mut idx = self.len() as isize;

                while idx > 0 {
                    idx -= 1;
                    res = Value::new(Pair::new(ctx.mutator(), self[idx as usize], res));
                }

                res
            }
        }
    }
}

pub type FormCompiler = fn(&mut Compiler, &mut Context, Value, bool) -> bool;
