All JSC runtime options:
   useKernTCSM=true   ... Note: this needs to go before other options since they depend on this value.
   validateOptions=false   ... crashes if mis-typed JSC options were passed to the VM
   dumpOptions=0   ... dumps JSC options (0 = None, 1 = Overridden only, 2 = All, 3 = Verbose)
   configFile=""   ... file to configure JSC options and logging location
   useLLInt=true   ... allows the LLINT to be used if true
   useJIT=true   ... allows the executable pages to be allocated for JIT and thunks if true
   useBaselineJIT=true   ... allows the baseline JIT to be used if true
   useDFGJIT=true   ... allows the DFG JIT to be used if true
   useRegExpJIT=true   ... allows the RegExp JIT to be used if true
   useDOMJIT=true   ... allows the DOMJIT to be used if true
   reportMustSucceedExecutableAllocations=false
   maxPerThreadStackUsage=5242880   ... Max allowed stack usage by the VM
   softReservedZoneSize=131072   ... A buffer greater than reservedZoneSize that reserves space for stringifying exceptions.
   reservedZoneSize=65536   ... The amount of stack space we guarantee to our clients (and to interal VM code that does not call out to clients).
   crashOnDisallowedVMEntry=false   ... Forces a crash if we attempt to enter the VM when disallowed
   crashIfCantAllocateJITMemory=false
   jitMemoryReservationSize=0   ... Set this number to change the executable allocation size in ExecutableAllocatorFixedVMPool. (In bytes.)
   forceCodeBlockLiveness=false
   forceICFailure=false
   forceUnlinkedDFG=false
   repatchCountForCoolDown=8
   initialCoolDownCount=20
   repatchBufferingCountdown=6
   initialRepatchBufferingCountdown=6
   dumpGeneratedBytecodes=false
   dumpGeneratedWasmBytecodes=false
   dumpBytecodeLivenessResults=false
   validateBytecode=false
   forceDebuggerBytecodeGeneration=false
   debuggerTriggersBreakpointException=false   ... Using the debugger statement will trigger an breakpoint exception (Useful when lldbing)
   dumpBytecodesBeforeGeneratorification=false
   useFunctionDotArguments=true
   useTailCalls=true
   optimizeRecursiveTailCalls=true
   alwaysUseShadowChicken=false
   shadowChickenLogSize=1000
   shadowChickenMaxTailDeletedFramesSize=128
   useIterationIntrinsics=true
   useOSLog=none   ... Log dataLog()s to os_log instead of stderr
   needDisassemblySupport=false
   dumpDisassembly=false   ... dumps disassembly of all JIT compiled code upon compilation
   asyncDisassembly=false
   logJIT=false
   dumpDFGDisassembly=false   ... dumps disassembly of DFG function upon compilation
   dumpFTLDisassembly=false   ... dumps disassembly of FTL function upon compilation
   dumpRegExpDisassembly=false   ... dumps disassembly of RegExp upon compilation
   dumpWasmDisassembly=false   ... dumps disassembly of all Wasm code upon compilation
   dumpWasmSourceFileName=""   ... log every wasm module validation, and dump source bytes to <filename>.0.wasm, <filename>.1.wasm, etc...
   wasmB3FunctionsToDump=""   ... file with newline separated list of function indices to dump IR/disassembly for, if no such file exists, the function index itself
   dumpBBQDisassembly=false   ... dumps disassembly of BBQ Wasm code upon compilation
   dumpOMGDisassembly=false   ... dumps disassembly of OMG Wasm code upon compilation
   logJITCodeForPerf=false
   bytecodeRangeToJITCompile=<null>   ... bytecode size range to allow compilation on, e.g. 1:100
   bytecodeRangeToDFGCompile=<null>   ... bytecode size range to allow DFG compilation on, e.g. 1:100
   bytecodeRangeToFTLCompile=<null>   ... bytecode size range to allow FTL compilation on, e.g. 1:100
   jitAllowlist=""   ... file with newline separated list of function signatures to allow compilation on or, if no such file exists, the function signature to allow
   dfgAllowlist=""   ... file with newline separated list of function signatures to allow DFG compilation on or, if no such file exists, the function signature to allow
   ftlAllowlist=""   ... file with newline separated list of function signatures to allow FTL compilation on or, if no such file exists, the function signature to allow
   dumpSourceAtDFGTime=false   ... dumps source code of JS function being DFG compiled
   dumpBytecodeAtDFGTime=false   ... dumps bytecode of JS function being DFG compiled
   dumpGraphAfterParsing=false
   dumpGraphAtEachPhase=false
   dumpDFGGraphAtEachPhase=false   ... dumps the DFG graph at each phase of DFG compilation (note this excludes DFG graphs during FTL compilation)
   dumpDFGFTLGraphAtEachPhase=false   ... dumps the DFG graph at each phase of DFG compilation when compiling FTL code
   dumpB3GraphAtEachPhase=false   ... dumps the B3 graph at each phase of compilation
   dumpAirGraphAtEachPhase=false   ... dumps the Air graph at each phase of compilation
   verboseDFGBytecodeParsing=false
   safepointBeforeEachPhase=true
   verboseCompilation=false
   verboseFTLCompilation=false
   logCompilationChanges=false
   printEachOSRExit=false
   validateDoesGC=false
   validateGraph=false
   validateGraphAtEachPhase=false
   verboseValidationFailure=false
   verboseOSR=false
   verboseDFGOSRExit=false
   verboseFTLOSRExit=false
   verboseCallLink=false
   verboseCompilationQueue=false
   reportCompileTimes=false   ... dumps JS function signature and the time it took to compile in all tiers
   reportBaselineCompileTimes=false   ... dumps JS function signature and the time it took to BaselineJIT compile
   reportDFGCompileTimes=false   ... dumps JS function signature and the time it took to DFG and FTL compile
   reportFTLCompileTimes=false   ... dumps JS function signature and the time it took to FTL compile
   reportTotalCompileTimes=false
   reportTotalPhaseTimes=false   ... This prints phase times at the end of running script inside jsc.cpp
   reportParseTimes=false   ... dumps JS function signature and the time it took to parse
   reportBytecodeCompileTimes=false   ... dumps JS function signature and the time it took to bytecode compile
   countParseTimes=false   ... counts parse times
   verboseExitProfile=false
   verboseCFA=false
   verboseDFGFailure=false
   verboseFTLToJSThunk=false
   verboseFTLFailure=false
   alwaysComputeHash=false
   testTheFTL=false
   verboseSanitizeStack=false
   useGenerationalGC=true
   useConcurrentGC=true
   collectContinuously=false
   collectContinuouslyPeriodMS=1
   forceFencedBarrier=false
   verboseVisitRace=false
   optimizeParallelSlotVisitorsForStoppedMutator=false
   largeHeapSize=33554432
   smallHeapSize=1048576
   smallHeapRAMFraction=0.8 (default: 0.25)
   smallHeapGrowthFactor=2
   mediumHeapRAMFraction=0.9 (default: 0.5)
   mediumHeapGrowthFactor=1.5
   largeHeapGrowthFactor=1.24
   miniVMHeapGrowthFactor=1.2
   criticalGCMemoryThreshold=0.8   ... percent memory in use the GC considers critical.  The collector is much more aggressive above this threshold
   customFullGCCallbackBailThreshold=-1   ... percent of memory paged out before we bail out of timer based Full GCs. -1.0 means use (maxHeapGrowthFactor - 1)
   minimumMutatorUtilization=0
   maximumMutatorUtilization=0.7
   epsilonMutatorUtilization=0.01
   concurrentGCMaxHeadroom=1.5
   concurrentGCPeriodMS=2
   useStochasticMutatorScheduler=true
   minimumGCPauseMS=0.3
   gcPauseScale=0.3
   gcIncrementBytes=10000
   gcIncrementMaxBytes=100000
   gcIncrementScale=0
   scribbleFreeCells=false
   sizeClassProgression=1.4
   preciseAllocationCutoff=100000
   dumpSizeClasses=false
   useBumpAllocator=true
   stealEmptyBlocksFromOtherAllocators=true
   eagerlyUpdateTopCallFrame=false
   dumpZappedCellCrashData=false
   useOSREntryToDFG=true
   useOSREntryToFTL=true
   useFTLJIT=true   ... allows the FTL JIT to be used if true
   validateFTLOSRExitLiveness=false
   defaultB3OptLevel=2
   b3AlwaysFailsBeforeCompile=false
   b3AlwaysFailsBeforeLink=false
   ftlCrashes=false
   clobberAllRegsInFTLICSlowPath=false
   enableJITDebugAssertions=false
   useAccessInlining=true
   maxAccessVariantListSize=8
   usePolyvariantDevirtualization=true
   usePolymorphicAccessInlining=true
   maxPolymorphicAccessInliningListSize=8
   usePolymorphicCallInlining=true
   usePolymorphicCallInliningForNonStubStatus=false
   maxPolymorphicCallVariantListSize=15
   maxPolymorphicCallVariantListSizeForTopTier=5
   maxPolymorphicCallVariantListSizeForWebAssemblyToJS=5
   maxPolymorphicCallVariantsForInlining=5
   frequentCallThreshold=2
   minimumCallToKnownRate=0.51
   createPreHeaders=true
   usePutStackSinking=true
   useObjectAllocationSinking=true
   useValueRepElimination=true
   useArityFixupInlining=true
   logExecutableAllocation=false
   maxDFGNodesInBasicBlockForPreciseAnalysis=20000   ... Disable precise but costly analysis and give conservative results if the number of DFG nodes in a block exceeds this threshold
   useConcurrentJIT=true   ... allows the DFG / FTL compilation in threads other than the executing JS thread
   numberOfWorklistThreads=3
   numberOfDFGCompilerThreads=2
   numberOfFTLCompilerThreads=7
   numberOfWasmCompilerThreads=15
   priorityDeltaOfDFGCompilerThreads=0
   priorityDeltaOfFTLCompilerThreads=0
   priorityDeltaOfWasmCompilerThreads=0
   useProfiler=false
   disassembleBaselineForProfiler=true
   useArchitectureSpecificOptimizations=true
   breakOnThrow=false
   maximumOptimizationCandidateBytecodeCost=100000
   maximumFunctionForCallInlineCandidateBytecodeCost=120
   maximumFunctionForClosureCallInlineCandidateBytecodeCost=100
   maximumFunctionForConstructInlineCandidateBytecoodeCost=100
   maximumFTLCandidateBytecodeCost=20000
   maximumInliningDepth=5   ... maximum allowed inlining depth.  Depth of 1 means no inlining
   maximumInliningRecursion=2
   maximumInliningCallerBytecodeCost=10000
   maximumVarargsForInlining=100
   maximumBinaryStringSwitchCaseLength=50
   maximumBinaryStringSwitchTotalLength=2000
   maximumRegExpTestInlineCodesize=500   ... Maximum code size in bytes for inlined RegExp.test JIT code.
   maximumWasmDepthForInlining=2   ... Maximum inlining depth to consider inlining a wasm function.
   maximumWasmCalleeSizeForInlining=200   ... Maximum wasm size in bytes to consider inlining a wasm function.
   maximumWasmCallerSizeForInlining=10000   ... Maximum wasm size in bytes for the caller of an inlined function.
   jitPolicyScale=1   ... scale JIT thresholds to this specified ratio between 0.0 (compile ASAP) and 1.0 (compile like normal).
   forceEagerCompilation=false
   thresholdForJITAfterWarmUp=500
   thresholdForJITSoon=100
   thresholdForOptimizeAfterWarmUp=1000
   thresholdForOptimizeAfterLongWarmUp=1000
   thresholdForOptimizeSoon=1000
   executionCounterIncrementForLoop=1
   executionCounterIncrementForEntry=15
   thresholdForFTLOptimizeAfterWarmUp=100000
   thresholdForFTLOptimizeSoon=1000
   ftlTierUpCounterIncrementForLoop=1
   ftlTierUpCounterIncrementForReturn=15
   ftlOSREntryFailureCountForReoptimization=15
   ftlOSREntryRetryThreshold=100
   evalThresholdMultiplier=10
   maximumEvalCacheableSourceLength=256
   maximumExecutionCountsBetweenCheckpointsForBaseline=1000
   maximumExecutionCountsBetweenCheckpointsForUpperTiers=50000
   likelyToTakeSlowCaseMinimumCount=20
   couldTakeSlowCaseMinimumCount=10
   osrExitCountForReoptimization=100
   osrExitCountForReoptimizationFromLoop=5
   reoptimizationRetryCounterMax=21 (default: 0)
   minimumOptimizationDelay=1
   maximumOptimizationDelay=5
   desiredProfileLivenessRate=0.75
   desiredProfileFullnessRate=0.35
   doubleVoteRatioForDoubleFormat=2
   structureCheckVoteRatioForHoisting=1
   checkArrayVoteRatioForHoisting=1
   maximumDirectCallStackSize=200
   minimumNumberOfScansBetweenRebalance=100
   numberOfGCMarkers=8
   useParallelMarkingConstraintSolver=true
   opaqueRootMergeThreshold=1000
   minHeapUtilization=0.8
   minMarkedBlockUtilization=0.9
   slowPathAllocsBetweenGCs=0   ... force a GC on every Nth slow path alloc, where N is specified by this option
   percentCPUPerMBForFullTimer=0.0003125
   percentCPUPerMBForEdenTimer=0.0025
   collectionTimerMaxPercentCPU=0.05
   forceWeakRandomSeed=false
   forcedWeakRandomSeed=0
   allowDoubleShape=true   ... debugging option to test disabling use of DoubleShape
   useZombieMode=false   ... debugging option to scribble over dead objects with 0xbadbeef0
   useImmortalObjects=false   ... debugging option to keep all objects alive forever
   sweepSynchronously=false   ... debugging option to sweep all dead objects synchronously at GC end before resuming mutator
   logGC=None   ... debugging option to log GC activity (0 = None, 1 = Basic, 2 = Verbose)
   useGC=true
   useGlobalGC=false
   gcAtEnd=false   ... If true, the jsc CLI will do a GC before exiting
   forceGCSlowPaths=false   ... If true, we will force all JIT fast allocations down their slow paths.
   forceDidDeferGCWork=false   ... If true, we will force all DeferGC destructions to perform a GC.
   gcMaxHeapSize=0
   forceRAMSize=0
   recordGCPauseTimes=false
   dumpHeapStatisticsAtVMDestruction=false
   forceCodeBlockToJettisonDueToOldAge=false   ... If true, this means that anytime we can jettison a CodeBlock due to old age, we do.
   useEagerCodeBlockJettisonTiming=false   ... If true, the time slices for jettisoning a CodeBlock due to old age are shrunk significantly.
   useTypeProfiler=false
   useControlFlowProfiler=false
   useSamplingProfiler=false
   sampleInterval=1000   ... Time between stack traces in microseconds.
   collectExtraSamplingProfilerData=false   ... This corresponds to the JSC shell's --sample option, or if we're wanting to use the sampling profiler via the Debug menu in the browser.
   samplingProfilerTopFunctionsCount=12   ... Number of top functions to report when using the command line interface.
   samplingProfilerTopBytecodesCount=40   ... Number of top bytecodes to report when using the command line interface.
   samplingProfilerIgnoreExternalSourceID=false   ... Ignore external source ID when aggregating results from sampling profiler
   samplingProfilerPath=""   ... The path to the directory to write sampiling profiler output to. This probably will not work with WK2 unless the path is in the sandbox.
   sampleCCode=false   ... Causes the sampling profiler to record profiling data for C frames.
   alwaysGeneratePCToCodeOriginMap=false   ... This will make sure we always generate a PCToCodeOriginMap for JITed code.
   randomIntegrityAuditRate=0.05   ... Probability of random integrity audits [0.0 - 1.0]
   verifyGC=false
   verboseVerifyGC=false
   verifyHeap=false
   numberOfGCCyclesToRecordForVerification=3
   exceptionStackTraceLimit=100   ... Stack trace limit for internal Exception object
   defaultErrorStackTraceLimit=100   ... The default value for Error.stackTraceLimit
   exitOnResourceExhaustion=false
   useExceptionFuzz=false
   fireExceptionFuzzAt=0
   validateDFGExceptionHandling=false   ... Causes the DFG to emit code validating exception handling for each node that can exit
   dumpSimulatedThrows=false   ... Dumps the call stack of the last simulated throw if exception scope verification fails
   validateExceptionChecks=false   ... Verifies that needed exception checks are performed.
   unexpectedExceptionStackTraceLimit=100   ... Stack trace limit for debugging unexpected exceptions observed in the VM
   validateDFGClobberize=false   ... Emits code in the DFG/FTL to validate the Clobberize phase
   validateBoundsCheckElimination=false   ... Emits code in the DFG/FTL to validate bounds check elimination
   useExecutableAllocationFuzz=false
   fireExecutableAllocationFuzzAt=0
   fireExecutableAllocationFuzzAtOrAfter=0
   fireExecutableAllocationFuzzRandomly=false
   fireExecutableAllocationFuzzRandomlyProbability=0.1
   verboseExecutableAllocationFuzz=false
   useOSRExitFuzz=false
   fireOSRExitFuzzAtStatic=0
   fireOSRExitFuzzAt=0
   fireOSRExitFuzzAtOrAfter=0
   verboseOSRExitFuzz=true
   seedOfVMRandomForFuzzer=0   ... 0 means not fuzzing this; use a cryptographically random seed
   useRandomizingFuzzerAgent=false
   seedOfRandomizingFuzzerAgent=1
   dumpFuzzerAgentPredictions=false
   useDoublePredictionFuzzerAgent=false
   useFileBasedFuzzerAgent=false
   usePredictionFileCreatingFuzzerAgent=false
   requirePredictionForFileBasedFuzzerAgent=false
   fuzzerPredictionsFile=""   ... file with list of predictions for FileBasedFuzzerAgent
   useNarrowingNumberPredictionFuzzerAgent=false
   useWideningNumberPredictionFuzzerAgent=false
   logPhaseTimes=false
   rareBlockPenalty=0.001
   maximumTmpsForGraphColoring=60000   ... The maximum number of tmps an Air program can have before always register allocating with Linear Scan
   airLinearScanVerbose=false
   airLinearScanSpillsEverything=false
   airForceBriggsAllocator=false
   airForceIRCAllocator=false
   airRandomizeRegs=false
   airRandomizeRegsSeed=0
   coalesceSpillSlots=true
   logAirRegisterPressure=false
   useB3TailDup=true
   maxB3TailDupBlockSize=3
   maxB3TailDupBlockSuccessors=3
   useB3HoistLoopInvariantValues=false
   useB3CanonicalizePrePostIncrements=false
   useDollarVM=false   ... installs the $vm debugging tool in global objects
   functionOverrides=""   ... file with debugging overrides for function bodies
   watchdog=0   ... watchdog timeout (0 = Disabled, N = a timeout period of N milliseconds)
   usePollingTraps=false   ... use polling (instead of signalling) VM traps
   useMachForExceptions=false (default: true)   ... Use mach exceptions rather than signals to handle faults and pass thread messages. (This does nothing on platforms without mach)
   useICStats=false
   prototypeHitCountForLLIntCaching=2   ... Number of prototype property hits before caching a prototype in the LLInt. A count of 0 means never cache.
   dumpCompiledRegExpPatterns=false
   verboseRegExpCompilation=false
   dumpModuleRecord=false
   dumpModuleLoadingState=false
   exposeInternalModuleLoader=false   ... expose the internal module loader object to the global space for debugging
   exposePrivateIdentifiers=false   ... Allow non-builtin scripts to use private identifiers. Mostly useful to expose @superSamplerBegin/End intrinsics for profiling
   useSuperSampler=false
   useSourceProviderCache=true   ... If false, the parser will not use the source provider cache. It's good to verify everything works when this is false. Because the cache is so successful, it can mask bugs.
   useCodeCache=true   ... If false, the unlinked byte code cache will not be used.
   useWebAssembly=true   ... Expose the WebAssembly global object.
   failToCompileWebAssemblyCode=false   ... If true, no Wasm::Plan will sucessfully compile a function.
   webAssemblyPartialCompileLimit=5000   ... Limit on the number of bytes a Wasm::Plan::compile should attempt before checking for other work.
   webAssemblyBBQAirOptimizationLevel=0   ... Air Optimization level for BBQ Web Assembly module compilations.
   webAssemblyBBQB3OptimizationLevel=1   ... B3 Optimization level for BBQ Web Assembly module compilations.
   webAssemblyOMGOptimizationLevel=2   ... B3 Optimization level for OMG Web Assembly module compilations.
   useBBQTierUpChecks=true   ... Enables tier up checks for our BBQ code.
   useWebAssemblyOSR=true
   thresholdForBBQOptimizeAfterWarmUp=150   ... The count before we tier up a function to BBQ.
   thresholdForBBQOptimizeSoon=50
   thresholdForOMGOptimizeAfterWarmUp=50000   ... The count before we tier up a function to OMG.
   thresholdForOMGOptimizeSoon=500
   omgTierUpCounterIncrementForLoop=1   ... The amount the tier up counter is incremented on each loop backedge.
   omgTierUpCounterIncrementForEntry=15   ... The amount the tier up counter is incremented on each function entry.
   useWebAssemblyFastMemory=true   ... If true, we will try to use a 32-bit address space with a signal handler to bounds check wasm memory.
   logWebAssemblyMemory=false
   webAssemblyFastMemoryRedzonePages=128   ... WebAssembly fast memories use 4GiB virtual allocations, plus a redzone (counted as multiple of 64KiB WebAssembly pages) at the end to catch reg+imm accesses which exceed 32-bit, anything beyond the redzone is explicitly bounds-checked
   crashIfWebAssemblyCantFastMemory=false   ... If true, we will crash if we can't obtain fast memory for wasm.
   crashOnFailedWebAssemblyValidate=false   ... If true, we will crash if we can't validate a wasm module instead of throwing an exception.
   maxNumWebAssemblyFastMemories=4
   useSinglePassBBQJIT=true   ... If true, BBQ will use the new single-pass WebAssembly baseline JIT as its compilation backend.
   wasmBBQUsesAir=true   ... If true, BBQ will use Air as its compilation backend.
   verboseBBQJITAllocation=false   ... Logs extra information about register allocation during BBQ JIT
   verboseBBQJITInstructions=false   ... Logs instruction information during BBQ JIT
   useWasmLLInt=true
   useBBQJIT=true   ... allows the BBQ JIT to be used if true
   useOMGJIT=true   ... allows the OMG JIT to be used if true
   useWasmLLIntPrologueOSR=true   ... allows prologue OSR from Wasm LLInt if true
   useWasmLLIntLoopOSR=true   ... allows loop OSR from Wasm LLInt if true
   useWasmLLIntEpilogueOSR=true   ... allows epilogue OSR from Wasm LLInt if true
   wasmFunctionIndexRangeToCompile=<null>   ... wasm function index range to allow compilation on, e.g. 1:100
   wasmLLIntTiersUpToBBQ=true
   webAssemblyBBQAirModeThreshold=0   ... If 0, we always use BBQ Air. If Wasm module code size hits this threshold, we compile Wasm module with B3 BBQ mode.
   useEagerWebAssemblyModuleHashing=false   ... Unnamed WebAssembly modules are identified in backtraces through their hash, if available.
   useArrayAllocationProfiling=true   ... If true, we will use our normal array allocation profiling. If false, the allocation profile will always claim to be undecided.
   forcePolyProto=false   ... If true, create_this will always create an object with a poly proto structure.
   forceMiniVMMode=false   ... If true, it will force mini VM mode on.
   useTracePoints=false
   traceBaselineJITExecution=false
   thresholdForGlobalLexicalBindingEpoch=4294967295   ... Threshold for global lexical binding epoch. If the epoch reaches to this value, CodeBlock metadata for scope operations will be revised globally. It needs to be greater than 1.
   diskCachePath=""
   forceDiskCache=false
   validateAbstractInterpreterState=false
   validateAbstractInterpreterStateProbability=0.5
   dumpJITMemoryPath=""
   dumpJITMemoryFlushInterval=10   ... Maximum time in between flushes of the JIT memory dump in seconds.
   useUnlinkedCodeBlockJettisoning=false   ... If true, UnlinkedCodeBlock can be jettisoned.
   forceOSRExitToLLInt=false   ... If true, we always exit to the LLInt. If false, we exit to whatever is most convenient.
   getByValICMaxNumberOfIdentifiers=4   ... Number of identifiers we see in the LLInt that could cause us to bail on generating an IC for get_by_val.
   useRandomizingExecutableIslandAllocation=false   ... For the arm64 ExecutableAllocator, if true, select which region to use randomly. This is useful for testing that jump islands work.
   exposeProfilersOnGlobalObject=false   ... If true, we will expose functions to enable/disable both the sampling profiler and the super sampler
   allowUnsupportedTiers=false   ... If true, we will not disable DFG or FTL when an experimental feature is enabled.
   returnEarlyFromInfiniteLoopsForFuzzing=false
   earlyReturnFromInfiniteLoopsLimit=1300000000   ... When returnEarlyFromInfiniteLoopsForFuzzing is true, this determines the number of executions a loop can run for before just returning. This is helpful for the fuzzer so it doesn't get stuck in infinite loops.
   useLICMFuzzing=false
   seedForLICMFuzzer=424242
   allowHoistingLICMProbability=0.5
   exposeCustomSettersOnGlobalObjectForTesting=false
   useJITCage=false
   dumpBaselineJITSizeStatistics=false
   dumpDFGJITSizeStatistics=false
   verboseExecutablePoolAllocation=false
   useDataICInFTL=false
   useDataICSharing=false
   useLLIntICs=true   ... Use property and call ICs in LLInt code.
   useBaselineJITCodeSharing=true
   libpasScavengeContinuously=false
   useWasmFaultSignalHandler=true
   dumpUnlinkedDFGValidation=false
   dumpWasmOpcodeStatistics=false
   dumpCompilerConstructionSite=false
   dumpWasmWarnings=false
   useArrayBufferTransfer=false   ... Expose ArrayBuffer.transfer feature.
   useArrayFromAsync=true   ... Expose the Array.fromAsync.
   useArrayGroupMethod=true   ... Expose the group() and groupToMap() methods on Array.
   useAtomicsWaitAsync=true   ... Expose the waitAsync() methods on Atomics.
   useSetMethods=true   ... Expose the various Set.prototype methods for handling combinations of sets
   useImportAssertion=false   ... Enable import assertion.
   useIntlDurationFormat=true   ... Expose the Intl DurationFormat.
   useResizableArrayBuffer=true   ... Expose ResizableArrayBuffer feature.
   useSharedArrayBuffer=true (default: false)
   useShadowRealm=false   ... Expose the ShadowRealm object.
   useStringWellFormed=true   ... Expose the String well-formed methods.
   useTemporal=false   ... Expose the Temporal object.
   useWebAssemblyThreading=true   ... Allow instructions from the wasm threading spec.
   useWebAssemblyTypedFunctionReferences=false   ... Allow function types from the wasm typed function references spec.
   useWebAssemblyGC=false   ... Allow gc types from the wasm gc proposal.
   forceAllFunctionsToUseSIMD=false   ... Force all functions to act conservatively w.r.t fp/vector registers for testing.
   useWebAssemblySIMD=true   ... Allow the new simd instructions and types from the wasm simd spec.
   useWebAssemblyTailCalls=false   ... Allow the new instructions from the wasm tail calls spec.
